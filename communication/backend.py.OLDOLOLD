'''
Created on Jul 23, 2011

@author: federico
'''
import serial, logging
logging.basicConfig(format='%(levelname)s:%(message)s thread %(thread)d', level=logging.DEBUG)

from threading import Lock, Thread
from Queue import Queue

from constants import paradox
import time

PORT = "/dev/ttyS0"

class BackendCommunicator(Thread):
    def __init__(self, event_callback):
        self.serial = serial.Serial(PORT, 57600, timeout=2)
        self.serial.flushInput()
        
        self.in_queue = Queue()
        self.out_queue = Queue()
        
        self.event_callback = event_callback
        
        self.lock = Lock()
        self.RequestInProgress = None
        self.running = True
        
        Thread.__init__(self)
        logging.warning("XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX BACKEND INIT COMPLETE XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX")
                
    def run(self):
        # Read all pending data
        count = 0
        logging.warning("XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX BACKEND RUN STARTED XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX")
        while self.running:
            logging.debug(">>>>> RIP VALUE " + str(count) + " " + str(self.RequestInProgress))
            count += 1
            if not self.in_queue.empty() and not self.RequestInProgress:
                request = self.in_queue.get(False)
                
                with self.lock:
                    logging.debug("---- have lock, sending data")
                    self.serial.write(request + "\r")
                    logging.debug("---- data sent")
                    time.sleep(0.1)
                    
                self.RequestInProgress = request

            with self.lock:
                try:
                    line = self.serial.readline(eol='\r').strip().upper()
                except:
                    line = ""
            
            if line != "":
                logging.debug("READ IN:" + line)
                if line.startswith("G"):
                    logging.debug("sent line for processing")
                    self._process(line)
                else:
                    if self.RequestInProgress:
                        result = self._verify(self.RequestInProgress, line)
                        
                        if result == "ok":
                            self.out_queue.put(line)
                        else:
                            self.out_queue.put(result)
                        self.RequestInProgress = None
                    else:
                        logging.warning("INVALID DATA: " + line)

            else:
                time.sleep(1)
                                                
    def request(self, request):
        self.in_queue.put(request)
        return self.out_queue.get(True)
    
    def _process(self, line):
        interpreted = paradox.interprete(line)
        if interpreted: self.event_callback(interpreted)
        
    def _verify(self, request, result):
        """
        timeout - no response received in time
        failed - response received with &fail
        ok - no problem
        error - something weird
        """
        logging.debug("verify called with request of '%s' and result of '%s'" %(request, result))

        if not result:
            return "timeout"
        elif result.endswith(paradox.FAIL):
            return "failed"
        else:
            if request[:5] == result[:5]:
                return "ok"
            else:
                return "error"
    
def cb(data):
    print data
    
if __name__ == "__main__":
    x = BackendCommunicator(cb)
    x.start()
    print x.request("VC004")
    print x.request("VO004")
    print x.request("VC004")
